---
layout: post
title:  "Virtual Memory II: Address Translation"
categories: [ Operating System ]
tags: [ Virtual Memory ]
similar: [ Operating System ]
featured: false
hidden: false
excerpt: Virtual Memory is an abstraction that the Operating System provides for managing memory. Virtual Memory enables a program to execute with less physical memory than it needs.
---

<br />

This post is adapted from Professor Remzi H. Arpaci-Dusseau and  Professor Andrea C. Arpaci-Dusseau's [OSTEP](http://pages.cs.wisc.edu/~remzi/OSTEP/){:target="_blank"} book, Chapter 13.

## Address Translation

To virtualize memory, the generic technique we use is `hardware-based address translation`, or `address translation`. With address translation, the **hardware** transforms each memory access (e.g. an instruction fetch, load, or store) by changing the virtual address provided by the instruction to a physical address where the desired information is actually located. The OS also gets involved by setting up the hardware so that the correct translations take place, keeping track of which locations are free and which are in use, and intervening to maintain control over how memory is used. 

The goal of all this work is to create an illusion that the program has its own private memory where its own code and data reside. From the program's perspective, its `address space` starts at address 0 and grows to a maximum of 16KB. All memory references it generates should be within these bounds. However, to virtualize memory, the OS wants to place the process somewhere else in physical memory, not necessarily at address 0. So how can we `relocate` this process in memory in a way that is transparent to the process?

#### Dynamic Relocation

The technique to support the address translation is referred to as `dynamic relocation`, also called `base and bounds`. Specifically, we will need two hardware registers within each CPU: one is called the `base` register, and the other is the `bounds` register. This base-and-bounds pair is going to allow us to place the address space anywhere we'd like in physical memory.

Each program is written and compiled as if it is loaded at address zero. When a program starts running, the OS decides where in physical memory it should be loaded and sets the `base` register to that value. Then when any memory reference is generated by the process, it is `translated` by the processor in the following manner:

physical address = virtual address + base

As this relocation of the address happens at runtime, and we can move address space even after the process has started running, this technique is often referred to as `dynamci relocation`.

The `bounds` register is to help with protection.  Specifically, the processor will first check that the memory reference is *within bounds* to make sure it is legal. The bounds register would always to set to 16 KB. If a process generates a virtual address that is greater than the bounds, or one that is negative, the CPU will raise an exception, and the process will likely be terminated. The point of the bounds is to make sure that all addresses generated by the process are legal and within the bounds of the process.

The base and bounds registers are hardware structures kept on the chip. The part of the processor that helps with address translation is the `memory management unit (MMU)`. The CPU also provides special instructions to allow the OS to modify the base and bounds registers. These instructions are priviledged and can only be executed in kernel mode. 

#### Operating System Issues

As we stated above, the combination of hardware support and OS management leads to the implementation of a simple virtual memory. Here are the things the OS must get involved.

First, when a process is created, the OS must find space for its address space in memory and then mark the space as used. 

Second, when a process is terminated, the OS reclaims all of the process' memory and cleans up associated data structures. 

Thrid, when a context switch occurs, the OS must *save and restore* the base-and-bounds pair when it switches between processes. Specifically, when the OS decides to stop running a process, it must save the values of the base and bounds registers to memory (such as process control block). When the OS resumes a running process, it must set the values of the base and bounds to the correct values for this process.

Fourth, the OS must provide exception handlers. If a process tries to access memory outside its bounds, the CPU will raise an exception; the OS must be prepared to take action when such an exception arises (e.g. terminate the process).
















